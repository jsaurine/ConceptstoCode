---
description: >-
  An introduction to designing structured algorithms using computational
  thinking, system modelling tools, and programming paradigms to develop
  efficient and scalable solutions.
---

# 120 Designing algorithms

This chapter introduces algorithm design as a structured problem-solving approach, incorporating computational thinking and system design principles. It explores key algorithmic features such as sequence, selection, and iteration, along with advanced strategies like divide and conquer and backtracking. Students will also engage with structured algorithm representations, including pseudocode, flowcharts, and subprograms, and learn to model systems using tools such as data flow diagrams and structure charts.

{% tabs %}
{% tab title="TARGETS" %}
In this chapter, you will learn to

* Define key features of standard algorithms, including sequence, selection, and iteration.
* Apply divide and conquer and backtracking as algorithmic design strategies.
* Develop structured algorithms using pseudocode and flowcharts, incorporating subprograms.
* Use system design tools, such as data flow diagrams and structure charts, to model algorithms.
* Analyse the logic and structure of written algorithms, identifying inputs, outputs, and subroutine relationships.
{% endtab %}

{% tab title="SYLLABUS" %}
New South Wales Education Standards Authority. (2022). _Software Engineering 11–12 Syllabus_. NSW Curriculum. [https://curriculum.nsw.edu.au/learning-areas/tas/software-engineering-11-12-2022](https://curriculum.nsw.edu.au/learning-areas/tas/software-engineering-11-12-2022/overview)

#### [**Programming fundamentals / Designing algorithms**](https://curriculum.nsw.edu.au/learning-areas/tas/software-engineering-11-12-2022/content/year-11/fac3c86ce1#cg-f9d7016a-6bf1-4264-90e9-c64be6835cdb)

* Apply computational thinking and algorithmic design by defining the key features of standard algorithms, including sequence, selection, iteration and identifying data that should be stored
* Apply divide and conquer and backtracking as algorithmic design strategies
* Develop structured algorithms using pseudocode and flowcharts, including the use of subprograms
* Use modelling tools including structure charts, abstraction and refinement diagrams to support top-down and bottom-up design
* Analyse the logic and structure of written algorithms, including determining inputs and outputs, determining the purpose of the algorithm, desk checking and peer checking, determining connections of written algorithms to other subroutines or functions

[**Programming fundamentals / Developing solutions with code**](https://curriculum.nsw.edu.au/learning-areas/tas/software-engineering-11-12-2022/content/year-11/fac3c86ce1#cg-ecd41d10-0c87-471a-b2de-1454076094d9)

* Apply skills in computational thinking and programming to develop a software solution, including converting an algorithm into code, using control structures, using data structures, using standard modules, and creating relevant subprograms that incorporate parameter passing
{% endtab %}

{% tab title="GLOSSARY" %}
* **Algorithm**\
  A step-by-step set of instructions designed to perform a specific task with a consistent output when run repeatedly..
* **Computational Thinking**\
  A structured approach to problem-solving that involves abstraction, decomposition, pattern recognition, and algorithm design.
* **Control Structures**\
  The fundamental constructs of algorithms—sequence, selection, and iteration.
* **Divide and Conquer**\
  An algorithmic strategy that recursively breaks a problem into smaller subproblems until they can be solved directly.
* **Backtracking**\
  A technique for solving problems incrementally by attempting solutions and discarding those that fail constraints.
* **Pseudocode**\
  A human-readable representation of an algorithm using structured logic statements.
* **Flowchart**\
  A diagrammatic representation of an algorithm using standard symbols to indicate control flow.
* **Data Flow Diagram (DFD)**\
  A graphical tool used to illustrate how data moves through a system.
* **Structure Chart**\
  A hierarchical diagram that represents the organisation of subprograms within a system.
{% endtab %}

{% tab title="RESOURCES" %}
[**Isaac Computer Science / Computational thinking principles**](https://isaaccomputerscience.org/concepts/dsa_ctm_computational_thinking_principles?examBoard=all\&stage=all\&topic=computational_thinking)

A comprenesive guide to computational thinking that underpins computing and digital making. It covers a broad range of knowledge and skills that can be used to develop effective solutions.

[**Isaac Computer Science / Designing algorithms**](https://isaaccomputerscience.org/concepts/soft_design_algorithms?examBoard=all\&stage=all)

An important part of software engineering is designing algorithms and programs to solve problems. This resourcce is a guide to designing, comparing and tracing algorithms
{% endtab %}
{% endtabs %}

### Algorithm design

Algorithm design is a fundamental aspect of software development, providing a structured approach to solving computational problems efficiently. Well-designed algorithms rely on key principles such as sequence, selection, and iteration to define logical workflows that achieve specific outcomes. More advanced strategies, like divide and conquer and backtracking, allow developers to break problems into smaller, more manageable components or systematically explore possible solutions. These techniques are essential for optimising performance and ensuring software applications can handle complex data processing tasks. By applying computational thinking, programmers can refine problem-solving approaches and construct algorithms that are both scalable and maintainable.

### System design

Beyond algorithm logic, system design plays a crucial role in structuring software solutions. Tools like data flow diagrams (DFDs) and structure charts help visualise how data moves through a system and how different subprograms interact. These modelling techniques support both top-down and bottom-up design approaches, enabling developers to create modular and efficient code. Understanding how to translate an algorithm into structured code—whether through pseudocode, flowcharts, or different programming paradigms—ensures that software solutions are well-organised and adaptable. By integrating algorithmic thinking with system design methodologies, software engineers can develop solutions that are not only functional but also optimised for performance and ease of maintenance.
