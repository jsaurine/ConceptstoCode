---
description: >-
  The three fundamental building blocks of algorithm design: sequence,
  selection, and iteration, are the control structures that form the foundation
  of programming.
---

# 122 Algorithm design

### TL:DR

Algorithm design is fundamental to software development, providing structured approaches to problem-solving. Three essential control structures—**sequence, selection, and iteration**—form the basis of all algorithms. **Sequence** ensures that instructions execute in a linear order, **selection** introduces decision-making through conditional statements, and **iteration** enables repetition using loops. These structures allow for efficient and logical program execution, making them crucial in developing functional software solutions.

By applying computational thinking, algorithms can be expressed in **pseudocode and flowcharts** before implementation in a programming language like Python. Flowcharts visually represent logical flow, while pseudocode provides a structured, language-independent way of describing an algorithm. Understanding these representations helps translate logic into working code. Additionally, structured algorithmic design techniques, such as **divide and conquer** and **backtracking**, improve problem-solving efficiency. These methods are widely used in optimising computational tasks and play a key role in developing scalable and maintainable software.

### Defining and representing algorithms

An algorithm is a **repeatable** set of steps that anyone can use to perform a task and solve part of a problem. The steps must have clear starting and end points and produce reliable output based on any appropriate input. An algorithm must be well-defined and not vague, with clearly communicated steps that anyone can understand and replicate, not just the original designer.

To design an algorithm that accomplishes a task, you have to think about the problem it is trying to solve in a certain way. This frame of mind is often called **algorithmic thinking**. To produce repeatable and clearly defined steps, you must be able to decompose the problem. You have to consider the inputs and outputs of your algorithm and the precise processes required to produce the desired output based on incoming data.

<figure><img src="../../.gitbook/assets/image (6).png" alt=""><figcaption><p>An algorithm represented in three different ways</p></figcaption></figure>

Another part of algorithmic thinking is the ability to represent your design and **communicate** your algorithm to other people. Design tools such as pseudocode, flowcharts, or structured English make algorithms easy to interpret while not requiring an understanding of any particular programming language (called 'language agnostic'). You can also communicate an algorithm in actual program code, but the code must be well documented. You can use both comments and formal technical documentation to help anyone who is not familiar with the particular language to understand it.

All these skills will also be helpful to you when you read and interpret algorithms created by others. You need to be able to read pseudocode, structured English, flowcharts, and well-documented program code to understand the algorithms presented to you.

### Key Concepts

> * **Sequence, selection, and iteration** are the three fundamental control structures in programming that form the basis of algorithm design.
> * **Sequence** refers to the order in which statements are executed in a program, proceeding step by step.
> * **Selection** (decision-making) structures allow programs to choose between alternatives based on conditions (using IF statements).
> * **Iteration** involves repeating code blocks through loops (For and While loops).
> * **Pseudocode** provides a language-independent way to plan algorithms before coding them.
> * **Flowcharts** visually represent algorithms using standardized symbols for different actions and decisions.
> * **Desk checking (trace tables)** helps validate algorithms by simulating execution and tracking variable values.
> * The Word Ladder game demonstrates the practical application of these concepts through controlled word transformation.
> * **Boolean** expressions are essential for creating conditions in selection and iteration structures.
> * An effective algorithm design considers both functionality and efficiency in problem-solving.
