---
description: >-
  The initial class files are created with method stubs to establish structure
  before implementation begins.
---

# 223.3 Creating initial class files with stubs

The class diagram was drafted during the system design process to clarify the responsibilities of each component in the app. Once the diagram was complete and the core behaviours were mapped out, two foundational Python modules: `task.py` and `task_manager.py` are created.

At this stage, the focus is not on implementing logic, but on defining structure. Method stubs and docstrings are used to outline the expected behaviour of each class. This makes it easier to review the design in code form, verify class responsibilities, and prepare for testing in future sprints.

### Method stubs

Method stubs are placeholder method definitions that include the method’s name, parameters, and a docstring, but no actual logic. In Python, the `pass` statement is used to indicate that the method is intentionally left empty.

#### Why use them?

In the early stages of development, especially when following an Agile process, method stubs allow the developer to:

* Translate design into code without immediately implementing every detail
* Clarify the interface of each class by showing what behaviours are expected
* Support incremental development, where each stub can be filled in during a specific sprint
* Make the code testable early, even if not fully functional

In this project, stubs were created after the class diagram was completed to ensure consistency between the design and implementation. They provide a scaffold that can be gradually expanded and tested during each sprint.

### task.py

The `Task` class models the data and actions associated with a single task. Here is one possible version of a structured file:

{% code title="task.py" lineNumbers="true" %}
```python
class Task:
    """
    Represents a task with a title, description, due date, and completion status.
    """

    def __init__(self, title, description, due_date):
        self.title = title
        self.description = description
        self.due_date = due_date
        self.completed = False

    def mark_complete(self):
        """Marks the task as complete."""
        pass

    def mark_incomplete(self):
        """Marks the task as incomplete."""
        pass

    def display_summary(self):
        """Prints a one-line summary of the task."""
        pass

    def display_details(self):
        """Prints the full details of the task."""
        pass
```
{% endcode %}

The constructor establishes the key attributes (lines 8-12), and the method stubs (lines 14-26) provide placeholders for behaviours identified in earlier design work.

### task\_manager.py

The `TaskManager` class acts as a controller for multiple tasks. It is essential to separate this logic from the individual task model to maintain clearly defined responsibilities.

{% code title="task_manager.py" lineNumbers="true" %}
```python
class TaskManager:
    """
    Manages a collection of Task objects and provides methods to manipulate them.
    """

    def __init__(self):
        self.tasks = []

    def add_task(self, task):
        """Adds a Task object to the internal list."""
        pass

    def remove_task(self, title):
        """Removes a task from the list by its title."""
        pass

    def list_tasks(self):
        """Prints all tasks currently in the list."""
        pass

    def find_task(self, title):
        """Searches for and returns a task by title."""
        pass

    def get_completed_tasks(self):
        """Returns a list of tasks marked as complete."""
        pass

    def get_incomplete_tasks(self):
        """Returns a list of tasks not yet completed."""
        pass
```
{% endcode %}

At this point, the methods are not implemented — the purpose is to ensure the interface is consistent with the design and to allow sprint-based development to begin incrementally.
