---
description: >-
  Learn how arrays store fixed-size collections of data and how they differ from
  Python lists
---

# 132.2 Arrays

### **What is an array?**

An **array** is a data structure that stores a collection of **elements of the same type** in a **fixed-size, indexed format**. Arrays are efficient for storing and processing large datasets, especially when the number of elements is known in advance.

While Python uses **lists** for most array-like operations, these are actually **dynamic arrays** that can hold different data types. True arrays (fixed in size and type) are used in lower-level or performance-sensitive contexts and are common in languages like C, Java, and Pascal.

To simulate arrays in Python, you can use:

* **The `array` module** (enforces type consistency)
* **NumPy arrays** (used for numerical computing)

### **Declaring a fixed-type array (using `array` module)**

Python’s built-in `array` module allows you to create arrays with a specified type code.

{% include "../../../.gitbook/includes/ps-python.md" %}

### **Accessing and modifying array elements**

Just like lists, arrays use zero-based indexing.

{% include "../../../.gitbook/includes/ps-python.md" %}

### **Fixed size and type**

Once created, an array:

* **Cannot grow or shrink** (unlike a list)
* **Must store only one data type** (e.g. all integers)

This makes arrays efficient in memory use, especially in embedded systems or games.

### **Looping through an array**

Arrays are often processed using `for` loops.

{% include "../../../.gitbook/includes/ps-python.md" %}

### **Multidimensional arrays**

Arrays can have more than one dimension. In Python, this is often done using **nested lists** or **NumPy arrays**.

{% include "../../../.gitbook/includes/ps-python.md" %}

For high-performance applications, use NumPy's `ndarray` for true multidimensional arrays.

### **Why use an array in Python instead of a list?**

While Python lists are more flexible and commonly used, **typed arrays** offer specific benefits in particular contexts. Here’s when you might use an array instead of a list:

**1. Memory efficiency**

Python lists store references to objects, meaning they can hold mixed types but use **more memory** per element.

Typed arrays (e.g. `array.array('i', [...])`) store values directly in memory in a contiguous block, similar to arrays in C. This is **more memory-efficient**, especially for large datasets of numbers.

**2. Type enforcement**

Arrays restrict all elements to a **single data type**, preventing accidental insertion of incompatible values.

```python
pythonCopyEditimport array
scores = array.array('i', [10, 20, 30])
scores.append("forty")   # Error: incompatible type
```

In a list, this would silently succeed — potentially causing bugs later.

**3. Performance**

For numerical data, arrays provide faster performance for operations that involve:

* Iteration over large datasets
* Numerical calculations
* File I/O in binary format (e.g. image or sound data)

For even better performance, especially for maths-heavy operations, **NumPy arrays (`ndarray`)** are the preferred structure. They support:

* Fast vectorised operations
* Broadcasting
* Integration with scientific libraries

**4. Interfacing with low-level code**

When working with:

* Binary files (e.g. `.wav`, `.bmp`)
* Hardware devices
* C/C++ extensions

Typed arrays (`array.array`) or NumPy arrays offer better compatibility because they mirror C-style memory layout.

### **Summary: list vs array**

| Feature     | `list`          | `array.array` (or `numpy.ndarray`)          |
| ----------- | --------------- | ------------------------------------------- |
| Stores      | Any type        | One fixed type only                         |
| Size        | Dynamic         | Fixed (or resizable with type checks)       |
| Memory use  | Higher          | Lower (more compact storage)                |
| Performance | Adequate        | Faster for numeric processing               |
| Use case    | General-purpose | Numeric data, file I/O, interfacing, memory |

### Conclusion

Use a **list** when:

* You need flexibility (e.g. mixed types, dynamic structure)
* You’re building general-purpose applications

Use an **array** when:

* You need speed, compact storage, or type control
* You're working with large amounts of numbers
* You're integrating with binary formats or low-level systems

### Key concepts

* An **array** stores a fixed-size collection of elements of the **same type**
* Arrays use **zero-based indexing** for access
* Python lists behave like dynamic arrays, but typed arrays can be created with modules like `array` or `numpy`
* Arrays are useful when memory and speed are critical, especially for large, numerical datasets
