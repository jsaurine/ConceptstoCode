---
description: >-
  Prevent security vulnerabilities caused by multiple processes accessing shared
  resources in unpredictable or unsafe ways.
---

# 422.43 Race conditions

### Overview

A race condition occurs when the behaviour of software depends on the timing or order of operations by multiple processes or threads. If two actions happen at the same time and access the same resource, unexpected results can occur, especially if the software does not correctly control access.

Race conditions are particularly dangerous in secure software because they can lead to:

* Unauthorised access
* Corrupted data
* Inconsistent system behaviour
* Privilege escalation

They are especially common in web applications, multi-threaded programs, and systems that rely on file or memory access.

### Targets

In this topic, students learn to:

* Explain how race conditions arise in software systems
* Identify where shared state or concurrent access may cause vulnerabilities
* Apply strategies to prevent race conditions during design and implementation
* Understand the consequences of insecure timing in concurrent systems

### Syllabus references

<details>

<summary><a href="https://curriculum.nsw.edu.au/learning-areas/tas/software-engineering-11-12-2022/content/year-12/fa039e749d">Secure software architecture</a></summary>

**Developing secure code**

* Design, develop and implement secure code to minimise vulnerabilities in user action controls, including:\
  –  race conditions

</details>

### What is a race condition?

A race condition happens when:

* Two or more operations access shared data or resources
* The operations are not properly ordered or synchronised
* The outcome depends on the sequence or timing of execution

#### Example (pseudo logic):

```
1. Check if a file exists
2. If it doesn’t, create the file
```

If two users run this code at the same time, they might both check for the file, see that it doesn’t exist, and both try to create it, which could result in an error or a security vulnerability.

### Real-world examples

* Banking systems: Two simultaneous withdrawals may bypass account balance checks
* Login bypass: Race condition in session token assignment allows multiple users to share a token
* File uploads: A temporary file is overwritten before validation occurs

### How to prevent race conditions

#### 1. Use locks and synchronisation

Ensure that only one thread or process can access a critical section of code at a time.

```
import threading

lock = threading.Lock()

def update_balance():
    with lock:
        # Perform sensitive operation
```

#### 2. Use atomic operations

Some operations can be executed as a single, uninterruptible unit. This prevents interference from other processes during the operation.

#### 3. Check and act together

Combine checks and actions into a single secured operation (e.g. use transaction blocks in databases).

#### 4. Design for thread safety

In multi-threaded programs, avoid shared global state and use immutable data structures where possible.

#### 5. Validate after action

Even if the system passed a validation check, confirm the outcome again after the action has taken place.

### Summary

* Race conditions are timing-related bugs that can introduce serious security flaws
* They often occur when two processes access or change the same resource without coordination
* Using locks, atomic operations, and transaction-based design can prevent these vulnerabilities
* Secure systems must be designed with concurrency and shared resource access in mind

```
---

Let me know if you'd like a visual diagram to illustrate a classic race condition (e.g. two processes accessing the same file) or if you’d like to proceed with `422.44 Invalid forwarding and redirecting`.
```
