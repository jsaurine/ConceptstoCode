---
description: >-
  Prevent attackers from bypassing login systems and impersonating users by
  implementing strong authentication and secure session handling.
---

# 422.42 Broken authentication

### Overview

Broken authentication refers to flaws in login systems that allow attackers to gain unauthorised access. This includes failures to protect credentials, enforce login limits, or manage user sessions securely. Once exploited, broken authentication can lead to identity theft, data breaches, and complete system compromise.

Insecure session management—such as using predictable session IDs or failing to expire them—also falls under this category. Secure software must ensure that users are who they claim to be and maintain that trust throughout the session.

### Targets

In this topic, students learn to:

* Identify weaknesses in login and session management logic
* Implement strong password handling and multi-factor authentication
* Securely generate, store, and expire session tokens
* Prevent attackers from impersonating users or escalating privileges

### Syllabus references

<details>

<summary><a href="https://curriculum.nsw.edu.au/learning-areas/tas/software-engineering-11-12-2022/content/year-12/fa039e749d">Secure software architecture</a></summary>

**Developing secure code**

* Design, develop and implement secure code to minimise vulnerabilities in user action controls, including:\
  –  broken authentication and session management

</details>

### What causes broken authentication?

Common vulnerabilities include:

* **Credential stuffing** – Using leaked usernames and passwords from other breaches
* **Brute-force attacks** – Trying many combinations to guess passwords
* **Session hijacking** – Stealing a session token and reusing it
* **Unexpired sessions** – Sessions stay valid indefinitely, even after logout
* **Predictable session IDs** – Makes it easy to guess or forge a valid session

### Best practices for secure authentication

#### 1. Use strong password policies

* Require a mix of letters, numbers, and symbols
* Enforce minimum length and password history
* Prevent use of common or breached passwords

#### 2. Store passwords securely

* Use one-way hashing with a strong algorithm (e.g. bcrypt, Argon2)
* Apply a salt to each password before hashing
* Never store plaintext or reversible passwords

#### 3. Implement multi-factor authentication (MFA)

* Require a second factor (e.g. SMS, authenticator app) for sensitive actions
* Protect against phishing and credential reuse

#### 4. Protect session tokens

* Use long, random session identifiers
* Set cookies with:
  * `HttpOnly` – Prevent access from JavaScript
  * `Secure` – Only transmit over HTTPS
  * `SameSite=Strict` – Prevent cross-site use
* Rotate tokens on login and privilege changes
* Invalidate tokens on logout or inactivity

#### 5. Limit login attempts

* Lock accounts temporarily after multiple failed logins
* Use CAPTCHA to block automated attempts
* Log suspicious access and notify users

### Example: Secure session management (Python Flask)

```python
from flask import session

# Generate session securely
session['user_id'] = user.id

# On logout
session.clear()
```

Ensure session cookies are configured in the application settings:

```python
app.config['SESSION_COOKIE_SECURE'] = True
app.config['SESSION_COOKIE_HTTPONLY'] = True
app.config['SESSION_COOKIE_SAMESITE'] = 'Strict'
```

### Summary

* Broken authentication allows attackers to bypass login and access user accounts
* Passwords must be hashed and never stored in plaintext
* Sessions must be securely generated, managed, and expired
* Multi-factor authentication and rate limiting add protection against brute-force attacks
