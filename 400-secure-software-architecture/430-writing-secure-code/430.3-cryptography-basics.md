---
description: >-
  Learn how cryptography is used in software code to protect passwords, secure
  data, and verify identity and how to avoid common mistakes.
---

# 430.3 Cryptography basics

### Objectives

* Understand how hashing, encryption, and secure token generation work in code
* Identify common cryptographic techniques used in authentication and data protection
* Recognise common implementation mistakes and how to avoid them

### Syllabus references

<details>

<summary><a href="https://curriculum.nsw.edu.au/learning-areas/tas/software-engineering-11-12-2022/content/year-12/fa039e749d">Secure software architecture</a></summary>

* Use and explain the contribution of cryptography and sandboxing to the ‘security by design’ approach in the development of software solutions
* Design, develop and implement secure code to minimise vulnerabilities in user action controls, including:\
  – broken authentication\
  – session management flaws

</details>

### Why cryptography in code matters

Cryptography isn't just a design principle — it’s something developers need to **implement carefully** in code.

If used incorrectly, cryptographic tools such as hashes and encryption can create **a false sense of security**. For example:

* Using outdated algorithms like MD5[^1]
* Forgetting to salt passwords before hashing
* Hardcoding secret keys in source code
* Reusing tokens or using weak randomness

### 1. Password hashing

Plain text passwords should **never** be stored or compared directly. Instead, hash them using a one-way function.

#### Example: using SHA-256[^2] (not recommended for passwords)

```python
import hashlib

def hash_password(password):
    return hashlib.sha256(password.encode()).hexdigest()
```

This hashes the password, but **SHA-256 is** [**too fast**](#user-content-fn-3)[^3] for secure password storage — attackers can brute-force millions of guesses per second.

### 2. Salted hashes

To make hashes more secure, add a **salt** — a random value stored alongside the password to prevent [rainbow table attacks](#user-content-fn-4)[^4].

#### Example: bcrypt (recommended for passwords)

```python
def create_hash(password):
    salt = bcrypt.gensalt()
    return bcrypt.hashpw(password.encode(), salt)
```

Bcrypt is slow by design, making brute-force attacks much harder. It also handles salting internally.

### 3. Symmetric encryption

Sometimes you need to encrypt and decrypt data (e.g. tokens, files, or private messages). Use a modern, high-level library with strong defaults.

#### Example: encrypting with Fernet (symmetric encryption)

```python
pythonCopyEditfrom cryptography.fernet import Fernet

key = Fernet.generate_key()
cipher = Fernet(key)

token = cipher.encrypt(b"Secret message")
plaintext = cipher.decrypt(token)
```

Store the key securely — if it’s exposed, anyone can decrypt the data.

### 4. Secure tokens and randomness

Tokens are often used for sessions, API access, or password resets. These must be **long, random, and unique**.

#### Example: generating a secure token

```python
import secrets

token = secrets.token_urlsafe(32)  # Random, unguessable
```

Avoid using `random` or manually generating short tokens — they can be guessed.

### Summary

* Use hashing (e.g. bcrypt) to store passwords securely
* Use modern encryption libraries like `Fernet` when data needs to be decrypted later
* Never hardcode secret keys or use outdated algorithms
* Always use secure randomness for tokens and secrets

Understanding these cryptographic tools in code helps you build systems that are not only secure in design, but **secure in practice**.

[^1]: The **MD5 (Message Digest 5)** algorithm is a fast cryptographic hash function that produces a 128-bit hash value. Although once widely used, it is now considered insecure because attackers can generate **collisions** — different inputs that produce the same hash. MD5 should not be used for password storage or cryptographic purposes in modern software.

[^2]: **SHA-256 (Secure Hash Algorithm 256-bit)** is a cryptographic hash function that produces a fixed 256-bit (64-character) output. It is widely used to ensure data integrity and securely store values like file checksums or blockchain transactions. Unlike MD5, SHA-256 is currently considered secure against collision attacks, but it is **too fast** for password hashing and should be used with caution in that context.

[^3]: A hash function is considered **too fast** when it allows attackers to make millions of password guesses per second in a brute-force or dictionary attack. Algorithms like SHA-256 are fast by design, making them unsafe for password storage. Instead, slower, purpose-built algorithms like **bcrypt** or **Argon2** are used to slow down guessing attempts and improve security.

[^4]: A **rainbow table attack** is a method used by attackers to crack hashed passwords by using precomputed tables of common passwords and their matching hash values. If a password hash appears in the table, the original password can be quickly found. These attacks are especially effective against unsalted hashes. Adding a **salt** — a unique random value per password — makes rainbow tables useless.
