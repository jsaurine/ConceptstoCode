---
description: >-
  Learn how cryptography is used in software code to protect passwords, secure
  data, and verify identity and how to avoid common mistakes.
---

# 430.3 Cryptography basics

Cryptography underpins secure software, from protecting passwords to securing data in transit. When used correctly, it helps prevent broken authentication and session hijacking; when used poorly, it creates a false sense of security. This topic explores cryptographic tools and their role in secure coding.

#### Objectives

* Understand how hashing, encryption and secure token generation work in code.
* Recognise standard cryptographic techniques used in authentication and data protection.
* Identify implementation mistakes (e.g. outdated algorithms, missing salts) and how they can contribute to broken authentication or session management flaws.

### Syllabus references

<details>

<summary><a href="https://curriculum.nsw.edu.au/learning-areas/tas/software-engineering-11-12-2022/content/year-12/fa039e749d">Secure software architecture</a></summary>

* Use and explain the contribution of cryptography and sandboxing to the ‘security by design’ approach in the development of software solutions
* Design, develop and implement secure code to minimise vulnerabilities in user action controls, including:\
  – broken authentication\
  – session management flaws

</details>

### Why cryptography in code matters

Cryptography isn't just a design principle — it’s something developers need to implement carefully in code.

If misused, cryptographic tools such as hashes[^1] and encryption can create a false sense of security. For example:

* Using outdated algorithms like MD5[^2]
* Forgetting to salt passwords before hashing
* Hardcoding secret keys in source code
* Reusing tokens or using weak randomness

### 1. Password hashing

**Hashing** is the process of converting input data (like a password or file) into a fixed-length string of characters, using a mathematical function called a **hash function**. The result is called a **hash** or **digest**.

Hashing is:

* **One-way** – it cannot be reversed to get the original input
* **Deterministic** – the same input always gives the same output
* **Used for integrity and security** – like storing passwords, verifying file changes, or indexing data

In secure coding, hashing is used to protect passwords and detect tampering. However, hashing must be combined with salt and a strong algorithm (like SHA-256 or bcrypt) to resist attacks like [rainbow tables](#user-content-fn-3)[^3] or brute-force.

Plain text passwords should **never** be stored or compared directly. Instead, hash them using a one-way function.

#### Example: using SHA-256[^4] (not recommended for passwords)

A hash is a one‑way transformation of data. To store passwords securely, compute a hash instead of saving the plain text. Use a **slow, purpose-built password hash (like bcrypt or Argon2) rather than fast general-purpose hashes such as MD5 or SHA-256**. Fast hashes allow attackers to brute‑force millions of guesses per second.

```python
import bcrypt

def hash_password(password):
    salt = bcrypt.gensalt()
    return bcrypt.hashpw(password.encode(), salt)
```

This code uses bcrypt, which automatically generates a salt and intentionally slows down hashing

### 2. Salted hashes

To make hashes more secure, add a **salt** — a random value stored alongside the password to prevent [rainbow table attacks](#user-content-fn-3)[^3].

A **salt** is a random value added to each password before hashing. It ensures that identical passwords produce different hashes, thwarting pre‑computed “rainbow table” attacks. Always generate a unique salt per user.

#### Example: bcrypt (recommended for passwords)

```python
def create_hash(password):
    salt = bcrypt.gensalt()
    return bcrypt.hashpw(password.encode(), salt)
```

Bcrypt is slow by design, making brute-force attacks much harder. It also handles salting internally.

### 3. Symmetric encryption

When you need to encrypt and later decrypt data (e.g. API tokens or private messages), use a modern, high‑level encryption library with secure defaults. Never hard‑code encryption keys in your codebase.

```python
from cryptography.fernet import Fernet

key = Fernet.generate_key()
cipher = Fernet(key)

ciphertext = cipher.encrypt(b"Secret message")
plaintext  = cipher.decrypt(ciphertext)
```

Store encryption keys securely (for example, in environment variables or a secrets manager); if the key is exposed, anyone can decrypt the data

### 4. Secure tokens and randomness

Tokens are used for sessions, API access and password resets. They must be long, unique and generated with a cryptographically secure random number generator. Use Python’s `secrets` module to generate unguessable values.

```python
import secrets
token = secrets.token_urlsafe(32)  # returns a 43-character URL-safe token
```

Always validate tokens on the server, set sensible expiration times and revoke them on logout to prevent session hijacking.

### Linking cryptography to authentication & session management

Cryptography is integral to secure authentication. Strong password hashing and salting prevent attackers from discovering credentials. Secure token generation supports stateless authentication schemes such as JSON Web Tokens. Conversely, using outdated hashes, weak randomness, or hard‑coded keys can lead to **broken authentication** and **session management flaws**.

For example:

* Storing passwords using MD5 or SHA‑1 makes them easy to crack.
* Reusing predictable session tokens allows attackers to hijack sessions.
* Embedding secret keys in source code exposes them to anyone who can access the repository.

To prevent these issues:

* Always choose slow password hashes (bcrypt, Argon2) with unique salts.
* Use a cryptographically secure random generator for tokens and session IDs.
* Keep encryption keys and tokens out of the codebase and rotate them regularly.
* Combine cryptography with proper **session management practices.**

#### Common mistakes & how to avoid them

* **Using outdated algorithms**\
  Avoid MD5 and SHA‑1; choose bcrypt or Argon2
* **Forgetting to salt**\
  Hashes without salts are vulnerable to rainbow tables
* **Hard‑coding keys**\
  Secrets should be stored securely outside your codebase
* **Predictable tokens**\
  Use `secrets` to generate random tokens and set expiration times
* **Assuming cryptography is a panacea**\
  Cryptography must be combined with access control, input validation and safe coding practices.

### Summary

Cryptography is a critical component of secure software architecture. By hashing and salting passwords, encrypting sensitive data, and generating secure tokens, you protect users’ identities and your system’s integrity. The syllabus expects you to implement these techniques correctly and understand how poor implementation can lead to broken authentication and session flaws. Sandboxing – covered in topic 420.3 – complements cryptography by isolating untrusted code. Together with proper session management, these practices ensure that security is built into your software from the ground up.

[^1]: **Hashing** is a one-way process that turns data into a fixed-length string (hash). Used to protect passwords or verify integrity. Secure systems use salted hashes and strong algorithms to prevent reverse-engineering or collisions.

[^2]: The **MD5 (Message Digest 5)** algorithm is a fast cryptographic hash function that produces a 128-bit hash value. Although once widely used, it is now considered insecure because attackers can generate **collisions** — different inputs that produce the same hash. MD5 should not be used for password storage or cryptographic purposes in modern software.

[^3]: A **rainbow table attack** is a method used by attackers to crack hashed passwords by using precomputed tables of common passwords and their matching hash values. If a password hash appears in the table, the original password can be quickly found. These attacks are especially effective against unsalted hashes. Adding a **salt** — a unique random value per password — makes rainbow tables useless.

[^4]: **SHA-256 (Secure Hash Algorithm 256-bit)** is a cryptographic hash function that produces a fixed 256-bit (64-character) output. It is widely used to ensure data integrity and securely store values like file checksums or blockchain transactions. Unlike MD5, SHA-256 is currently considered secure against collision attacks, but it is **too fast** for password hashing and should be used with caution in that context.
