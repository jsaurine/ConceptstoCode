---
description: >-
  Learn how to write secure and efficient code by managing memory, sessions, and
  exceptions and how these practices prevent vulnerabilities like session
  hijacking.
---

# 430.4 Managing memory, sessions, exceptions

### Objectives

* Apply memory, session, and exception management strategies to improve software performance and resilience
* Recognise how poor handling of these features can lead to security risks and unstable behaviour
* Understand how session flaws contribute to vulnerabilities like session hijacking or unauthorised access

### Syllabus references

<details>

<summary><a href="https://curriculum.nsw.edu.au/learning-areas/tas/software-engineering-11-12-2022/content/year-12/fa039e749d">Secure software architecture</a></summary>

* Design, develop and implement code considering efficient execution for the user, including:\
  – memory management\
  – session management\
  – exception management

- Design, develop and implement secure code to minimise vulnerabilities in user action controls, including:\
  – broken authentication\
  – session management flaws\
  \- race conditions

</details>

### Memory management

Memory management refers to how a program allocates and releases system memory during execution. If memory is not released correctly, or if data is written outside the expected boundaries, programs may:

* Slow down over time
* Crash unexpectedly
* Introduce security vulnerabilities like buffer overflows.

Most high-level languages (like Python and Java) include **garbage collection**, but developers still need to manage resources carefully.

#### Example: managing file memory safely in Python

```python
# Poorer practice
file = open('data.txt')
contents = file.read()
# File is still open unless you explicitly close it
file.close()

# Automatically closes the file after reading it, even if an error occurs
with open('data.txt') as file:
    contents = file.read()
```

This `with` block automatically closes the file after reading it, even if an error occurs. This helps prevent memory leaks and keeps system resources available for other processes.

### Session management

Sessions track user identity and maintain state between interactions with a web application. If not managed securely, sessions can be **hijacked**, giving attackers unauthorised access to user accounts.

Common risks include:

* Exposed session tokens
* Sessions that never expire
* Insecure logout or session reuse

#### Example: Flask session with timeout

```python
session['user_id'] = user.id
session.permanent = True  # Enables expiry after a fixed time
```

In this example, the session stores the logged-in user’s ID and is marked as “permanent”, allowing the app to apply an expiry time (e.g. 30 minutes). This reduces the risk of session hijacking if a user walks away from a shared device.

#### Additional protections

* Use **HTTPS** to encrypt session data in transit
* Regenerate session IDs on login
* Invalidate sessions after logout or timeout

### Exception handling

Exceptions occur when something unexpected happens in the program, such as attempting to divide by zero, accessing a nonexistent file, or failing to connect to a server. If these errors are not handled, they can:

* Crash the application
* Leak sensitive information (e.g. stack traces)
* Allow attackers to infer system behaviour

A secure system **handles errors gracefully**, logs them appropriately, and avoids giving users too much information.

#### Example: safely catching a ZeroDivisionError

```python
try:
    result = calculate_average(scores)
except ZeroDivisionError:
    result = 0  # Prevents crash if scores is empty
```

This code prevents a crash by catching a known error and providing a fallback value. In a real application, you might also log the error (internally) and show the user a simple message like “No scores available”.

### Race conditions

A **race condition** occurs when two or more processes or threads access shared data at precisely the same time, and the outcome depends on the timing of those accesses. This can lead to **unpredictable behaviour, crashes, or data corruption**.

Race conditions are often hard to detect and may occur only under specific conditions (e.g. heavy load).

#### Example:

If two users attempt to register the same username simultaneously, and the system fails to check or lock the database properly, both could be allowed, resulting in inconsistencies or access issues.

#### Prevention:

* Use **atomic operations** or database-level constraints.
* Apply **locking mechanisms** in multithreaded environments
* Always validate the result of concurrent operations before committing changes

### Summary

* **Memory management** improves performance and prevents resource leaks
* **Session management** protects user identity and reduces the risk of hijacking
* **Exception handling** ensures systems fail safely without exposing sensitive data\
  These practices are essential for both **efficient execution** and **secure software architecture**. They reflect the principle of **security by design**, where protection is built into the system from the outset.
* **Race conditions** can lead to unpredictable behaviour in concurrent systems and should be managed with careful control of shared resources
