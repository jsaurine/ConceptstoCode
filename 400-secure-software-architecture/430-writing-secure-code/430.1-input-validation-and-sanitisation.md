---
description: >-
  Learn how to validate and sanitise user input to protect your software from
  crashes, corrupted data, and attacks like code injection.
---

# 430.1 Input validation and sanitisation

### Objectives

* Explain the importance of input validation and sanitisation in secure coding
* Identify techniques that prevent unauthorised or dangerous input
* Apply secure coding patterns to reduce the risk of injection and other common threats

### Syllabus references

<details>

<summary><a href="https://curriculum.nsw.edu.au/learning-areas/tas/software-engineering-11-12-2022/content/year-12/fa039e749d">Secure software architecture</a></summary>

* Design, develop and implement code using defensive data input handling practices, including:\
  – input validation\
  – sanitisation\
  – error handling

</details>

### What is input validation?

**Input validation** is the process of checking that all input your program receives is correct, expected, and safe. This includes data from:

* Forms and user interfaces
* URLs and [query strings](#user-content-fn-1)[^1]
* Cookies[^2] and session variables
* Files, APIs, and databases

Input that is not checked correctly can lead to serious security vulnerabilities — including [**code injection**](#user-content-fn-3)[^3], [**XSS**](#user-content-fn-4)[^4], and [**data corruption**](#user-content-fn-5)[^5].

#### Key principle: Never trust user input

Always assume that any input could be:

* Incorrect (e.g. a letter where a number is expected)
* Malicious (e.g. trying to inject JavaScript or SQL code)
* Unexpected (e.g. too long, missing, or out of range)

### Validation vs sanitisation

<table data-header-hidden><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>Validation</strong></td><td><strong>Sanitisation</strong></td></tr><tr><td>Confirms input is correct and safe</td><td>Cleans input to remove harmful elements</td></tr><tr><td>Used to reject bad input early</td><td>Used when input must be accepted but made safe</td></tr><tr><td>Example: Must be a number between 1–10</td><td>Example: Strip tags from a comment field</td></tr><tr><td><p>This is an example of a validation rule used to ensure that user input meets expected criteria before the program accepts it.</p><p><strong>What it means:</strong><br>The system expects a <strong>numeric value</strong>, and only values from <strong>1 to 10</strong> are considered valid. Any other input—such as letters, symbols, or numbers outside that range—is <strong>rejected</strong>.</p><p><strong>Why it matters:</strong><br>Without validation, users (or attackers) could input values that break the logic of your program, cause errors, or even create security risks. For example:</p><ul><li>Entering <code>-1</code> or <code>9999</code> might crash the program or cause incorrect calculations.</li><li>Entering a <strong>string</strong> like <code>"hello"</code> could cause a type error.</li><li>Injecting code like <code>"10; DROP TABLE users;"</code> might exploit a database if it’s not protected.</li></ul><p><strong>How it's implemented:</strong></p><ul><li>First, check that the input is a number (not a string or other type).</li><li>Then, check that it falls within the allowed range: <code>1 ≤ input ≤ 10</code>.</li></ul><p><strong>Example in pseudocode:</strong></p><pre><code>IF input is a number AND input >= 1 AND input &#x3C;= 10 THEN
    accept input
ELSE
    reject input with error message
ENDIF
</code></pre><p>This kind of <strong>defensive validation</strong> ensures the software behaves reliably and securely.</p></td><td><p>This example refers to a common technique used to prevent <strong>XSS (Cross-Site Scripting)</strong> attacks. When users submit a comment (or any text input), they might try to include HTML or JavaScript code, such as:</p><pre class="language-html"><code class="lang-html">&#x3C;script>alert("Hacked!");&#x3C;/script>
</code></pre><p>If the website simply displays this input without filtering it, the script will run in another user’s browser, which is dangerous.</p><p><strong>Stripping tags</strong> means removing all HTML tags from the input before displaying it, so this:</p><pre><code>&#x3C;script>alert("Hacked!");&#x3C;/script>
</code></pre><p>becomes:</p><pre><code>alert("Hacked!");
</code></pre><p>Or, in most cases, the whole thing is removed so only plain text remains.</p><p><strong>Why it matters:</strong></p><p>Removing HTML tags helps prevent attackers from injecting code. It ensures that the comment is treated as <strong>text only</strong>, not executable code.</p><p><strong>In Python</strong>, this might be done using a sanitisation library like <code>bleach</code> or <code>html.escape()</code>. In JavaScript, you might escape the characters or use a secure rendering function.</p></td></tr></tbody></table>

Both are important — but **validate first**, and only sanitise if necessary.

### Safe input validation strategies

#### 1. Whitelist (allow only known good input)

Reject everything except exactly what is expected.

✅ **Good:**

```python
if age in range(13, 100):
    register_user()
```

❌ **Avoid:**

```python
if not "DROP" in input_text:
    run_query(input_text)  # Too broad
```

#### 2. Use built-in validation functions

Where possible, use trusted libraries or frameworks that provide built-in validation support (e.g., regular expressions, form validators, schema validators).

#### 3. Validate all fields — even hidden ones

Don’t assume that dropdowns, hidden fields, or cookies are safe. Attackers can change them.

### Common validation mistakes

* **Relying only on client-side validation** (JavaScript can be bypassed)
* **Failing to check length or format** of strings (e.g. unlimited length usernames)
* **Allowing unchecked file uploads** (e.g. accepting `.exe`, `.php`, or very large files)
* **Assuming numeric input is safe** (e.g. entering `0 OR 1=1` into a login form)

### Example: Python form validation

```python
def validate_age(age):
    if not age.isdigit():
        return False
    age_int = int(age)
    return 13 <= age_int <= 120
```

This function ensures that the age is a numeric value and falls within a reasonable range.

### Summary

* Input validation checks that data is correct, expected, and safe before using it
* Sanitisation cleans input when rejection is not possible
* Never trust user input — validate everything, server-side
* Good input validation prevents common vulnerabilities like code injection and corrupted data

### Questions

1. **Define input validation in the context of registering as a new user on a web app and creating a username and password.**

<details>

<summary>Answer</summary>

**Input validation** is the process of checking that user input meets expected criteria before being processed or stored. When registering a new user, the web app should validate the username to ensure it contains only allowed characters (e.g. letters, numbers, underscores) and is the correct length. The password should also be validated to ensure it meets minimum complexity requirements, such as a minimum length and a mix of character types. This prevents malformed or malicious input from reaching the server or database.

</details>

2. **Explain how input validation can make html form tags more secure.**

<details>

<summary>Answer</summary>

HTML form tags become more secure when input validation is applied because it prevents users from entering data that could exploit vulnerabilities in the system. For example, a `<textarea>` used for a comment field should reject scripts or unusual characters that might be used in a cross-site scripting (XSS) attack. Validation at both the client-side (e.g. with HTML5 attributes like `type="email"` or [`pattern`](#user-content-fn-6)[^6]) and server-side ensures that only expected data types are accepted, reducing the risk of injection, corruption or misuse.

</details>

3. **Outline THREE vulnerabilities that can arise from poor input validation.**

<details>

<summary>Answer</summary>

**Code injection** – Malicious input can be used to inject code into a system, such as SQL injection or cross-site scripting (XSS), if not properly checked.

**Data corruption** – Invalid or unexpected input can break the application logic or corrupt stored data, especially in structured formats like databases or files.

**Security bypass** – Attackers might manipulate form inputs (e.g. changing hidden values) to gain access to restricted features or escalate privileges if validation is weak or missing.

</details>

4. **Give THREE reasons why user input should never be trusted.**

<details>

<summary>Answer</summary>

**Users can make mistakes** – Input might be incomplete, wrongly formatted, or outside the expected range, even when not malicious.

**Users can manipulate data** – Attackers can bypass client-side controls using browser developer tools, interceptors, or custom scripts.

**Attack vectors are often disguised as input** – Hackers may use input fields to embed scripts, malformed data, or hidden payloads intended to exploit vulnerabilities.

</details>

5. **After a user securely signs into a website, they post comments on an article written by a blogger. Explain how sanitisation is used in this context to reduce vulnerabilities and improve security.**

<details>

<summary>Answer</summary>

Sanitisation is the process of cleaning input data to remove or neutralise harmful content. In the context of blog comments, sanitisation strips or escapes any embedded scripts, HTML tags, or malicious code that a user might attempt to include in their comment. For example, the `<script>` tag could be removed or encoded to prevent the browser from executing it. This helps prevent cross-site scripting (XSS) attacks and ensures that only safe, displayable content is stored and shown to other users.

</details>

6. **Outline some security-by-design principles for validating a username and password during the signup process for a website.**

<details>

<summary>Answer</summary>

Security-by-design principles for validating usernames and passwords include:

* **Whitelist validation** – Accept only known safe patterns for usernames (e.g. alphanumeric and underscore, 3–20 characters).
* **Password strength rules** – Require minimum length, and a mix of upper/lowercase letters, numbers and symbols.
* **Avoid feedback that reveals security logic** – Use generic error messages like “Invalid username or password” rather than specifying which field failed.
* **Rate limiting and CAPTCHA** – Protect the signup form from automated brute-force attacks.
* **Hashing passwords** – Never store passwords in plain text; use secure hashing algorithms like bcrypt or Argon2.
* **Server-side validation** – Always recheck input on the server, even if it's been validated in the browser.

</details>



[^1]: Text appended to a URL after a `?`, used to send data to the server (e.g. `?user=123`). Query strings can be manipulated by users, so inputs should always be validated and sanitised to prevent security vulnerabilities such as injection attacks or data leakage.

[^2]: Small pieces of data stored by a website in the user's browser to remember information across sessions, such as login status or preferences. Secure code must protect cookies from tampering by setting attributes like `HttpOnly`, `Secure`, and `SameSite` to prevent cross-site scripting (XSS) or cross-site request forgery (CSRF) attacks.

[^3]: A type of attack where malicious input is inserted into a program to change its intended behaviour, often by exploiting unsanitised input fields. Common forms include SQL injection and script injection, which can lead to data breaches or unauthorised control of a system.

[^4]: **XSS (Cross-Site Scripting)** is a security vulnerability where attackers inject malicious scripts into webpages viewed by other users. XSS exploits occur when user input is not properly sanitised, allowing attackers to run scripts in the victim's browser—often used to steal cookies, session tokens or redirect users to malicious sites.

[^5]: The unintended alteration of data during storage, processing or transmission, often due to bugs, hardware faults, or insecure code. It can lead to loss of data integrity, application crashes, or unpredictable behaviour. Secure programming practices help prevent corruption by validating inputs, handling exceptions properly, and using safe storage mechanisms.

[^6]: `pattern` refers to a **regular expression** (regex) that defines acceptable input formats for a form field in HTML.

    For example, in an HTML form field like:

    {% code overflow="wrap" %}
    ```html
    <input type="text" name="username" pattern="^[a-zA-Z0-9_]{3,20}$">
    ```
    {% endcode %}

    The `pattern` attribute specifies that the input must:

    * start and end (`^` and `$`) with
    * letters (`a-z`, `A-Z`), digits (`0-9`), or underscores (`_`)
    * and be between 3 and 20 characters long (`{3,20}`).

    This helps enforce constraints on what users can type _before_ the form is even submitted, which makes the form more secure and user-friendly. It’s a form of client-side input validation.
