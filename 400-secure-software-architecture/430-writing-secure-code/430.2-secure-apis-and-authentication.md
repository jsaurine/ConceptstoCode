---
description: >-
  Understand what APIs are, why they matter, and how to protect them using
  strong authentication and secure coding practices.
---

# 430.2 Secure APIs and authentication

### Objectives

* Explain what APIs are and how they are used in software systems
* Identify common security risks in poorly secured APIs
* Apply authentication and access control to reduce threats like broken authentication and data leaks

### Syllabus references

<details>

<summary><a href="https://curriculum.nsw.edu.au/learning-areas/tas/software-engineering-11-12-2022/content/year-12/fa039e749d">Secure software architecture</a></summary>

* Design, develop and implement a safe application programming interface (API) to minimise software vulnerabilities
* Design, develop and implement secure code to minimise vulnerabilities in user action controls, including:\
  – broken authentication\
  – session management flaws

</details>

APIs are the glue that binds modern software together. They expose powerful functionality — but if you don’t lock them down, they also expose your system to attackers. This module explains what APIs are, how standard authentication methods work, why session management matters even in “stateless” APIs, and how to defend against broken authentication and session hijacking.

{% embed url="https://gamma.app/embed/ly5ju52o6qqdrqq" fullWidth="false" %}

### What is an API?

An API (Application Programming Interface) enables one program to communicate with another. When your timetable app fetches your schedule from the server, it calls an API. When a weather widget shows current conditions, it calls an API. APIs define the rules and formats (often JSON or XML) for sending and receiving data.

### Why API security matters

APIs often sit at the boundary between a software system and the outside world. If they are not protected, attackers can:

* Access private data or someone else’s account.
* Bypass the login system and perform unauthorised actions.
* Flood the server with requests (denial of service).

### Authentication vs authorisation

**Authentication** verifies _who_ is making a request — it’s about identity.

**Authorisation** determines _what_ an authenticated user is allowed to do. A student should not be able to access admin features. Robust API security requires both.

### Common API authentication methods

1. **HTTP Basic authentication** – sends a Base64‑encoded username/password pair in an `Authorization` header. It must be used over HTTPS to prevent eavesdropping, and it offers no protection against replay[^1] or brute‑force[^2] attacks.
2. **API keys** – unique identifiers issued to each client. Keys must be sent with every request and kept secret. Like passwords, they should be rotated regularly and never hard‑coded in public code repositories.
3. **JWT (JSON Web Token)** – a signed and optionally encrypted token that contains the user’s identity. JWTs are stateless; the server verifies the signature rather than looking up a session. Set reasonable expiration times and avoid storing sensitive data in the token.
4. **OAuth 2.0** – a token‑based protocol that allows users to grant limited access to third‑party applications. It is the gold standard for delegated authorisation and underpins “Sign in with Google/GitHub” flows.

<table data-card-size="large" data-view="cards" data-full-width="true"><thead><tr><th></th><th></th><th data-hidden data-card-cover data-type="files"></th></tr></thead><tbody><tr><td><strong>HTTP Basic Authentication</strong></td><td>HTTP basic authentication is the most rudimentary way to implement API authentication. It involves sending credentials as user/password pairs in an <code>Authorization</code> header field, where the credentials are encoded using Base64. However, these credentials </td><td><a href="../../.gitbook/assets/http-basic-auth-diagram-postman.svg">http-basic-auth-diagram-postman.svg</a></td></tr><tr><td><strong>API Key Authentication</strong></td><td>An API key is a unique identifier that an API provider issues to registered users in order to control usage and monitor access. The API key must be sent with every request—either in the query string, as a request header, or as a cookie. Like HTTP basic authentication, API key authentication must be used with HTTPS to ensure the API key remains secure.</td><td><a href="../../.gitbook/assets/api-key-auth-diagram-postman.svg">api-key-auth-diagram-postman.svg</a></td></tr><tr><td><strong>JWT authentication</strong></td><td>JWT, which stands for JSON Web Token, is a compact, stateless mechanism for API authentication. When a user logs into an application, the API server creates a digitally signed and encrypted JWT that includes the user's identity. The client then includes the JWT in every subsequent request, which the server deserialises and validates. The user's data is therefore not stored on the server's side, which improves scalability.</td><td><a href="../../.gitbook/assets/jwt-auth-diagram-postman.svg">jwt-auth-diagram-postman.svg</a></td></tr><tr><td><strong>OAuth authentication</strong></td><td>OAuth is a token-based authentication mechanism that enables a user to grant third-party access to their account without having to share their login credentials. OAuth 2.0, which provides greater flexibility and scalability than OAuth 1.0, has become the gold standard for API authentication, and it supports extensive API integration without putting user data at risk.</td><td><a href="../../.gitbook/assets/oauth-diagram-postman.svg">oauth-diagram-postman.svg</a></td></tr></tbody></table>

### Session management & tokens

Even when using tokens, a [**session**](#user-content-fn-3)[^3] operates between client and server. Poor session management can lead to hijacking, fixation or leakage. Best practices include:

* **Generate strong, random session tokens**. Use a cryptographically secure generator and ensure tokens are long and unguessable
* **Always use HTTPS**. Set the `Secure` flag on cookies so they are only sent over encrypted connections. This prevents attackers from capturing tokens over unencrypted channels.
* **Use `HttpOnly` cookies**. Setting the `HttpOnly` attribute prevents JavaScript from accessing session cookies. This mitigates theft via cross‑site scripting.
* **Set `SameSite`**. The `SameSite` attribute reduces the risk of cross‑site request forgery by blocking cookies from being sent with cross‑origin requests.
* **Restrict cookie scope**. Specify narrow `Domain` and `Path` attributes so cookies are only sent to the correct application. Avoid sharing session cookies across subdomains.
* **Implement expiration and renewal**. Session tokens should expire after a short idle period and an absolute lifetime. Regenerate tokens after privilege changes (e.g. after a user logs in or elevates privileges) to prevent fixation.
* **Revoke tokens on logout**. Whether you store sessions in a database or rely on JWTs, implement a server‑side blacklist or short expiry so a logged‑out token cannot be reused.
* **Limit concurrent sessions**. Depending on your security requirements, restrict the number of active sessions per user and alert on unusual patterns.

By treating session IDs and tokens as sensitive user input and enforcing strict handling rules, you minimise the risk of session hijacking and replay attacks.

### Broken authentication & how to prevent it

Broken authentication occurs when flaws in your login or session management allow attackers to impersonate users. Typical weaknesses include weak passwords, [credential stuffing](#user-content-fn-4)[^4], absent [rate limiting](#user-content-fn-5)[^5], and failure to invalidate tokens. To defend against them:

* Enforce strong password policies (minimum length, complexity, no reuse).
* Implement multi‑factor authentication (MFA) for sensitive operations.
* Rate‑limit login attempts and introduce exponential back‑off or CAPTCHAs to deter brute‑force attacks.
* Lock accounts temporarily after repeated failed logins.
* Store passwords using a strong hashing algorithm with salting (see §430.3) and never store plain-text credentials.
* Do not rely on default or hard‑coded credentials.
* Always validate tokens and session IDs on every request, and ensure they expire and are revoked appropriately.

### Securing APIs

In addition to robust authentication and session management, secure APIs follow these principles:

1. **Use HTTPS everywhere** to protect data in transit.
2. **Authenticate every request**; do not assume a session is valid just because the client sent a token.
3. **Enforce authorisation** using role‑based access control or attribute‑based policies.
4. **Validate and sanitise input** to prevent injection and other attacks.
5. **Limit exposure**: only return data that is necessary; avoid leaking internal identifiers.
6. **Rate‑limit and monitor** API usage. Detect anomalies, log errors, and respond to abuse.
7. **Keep secrets out of source code** – store API keys and secrets in secure configuration services or environment variables.

### Summary

APIs are the gateways to your application’s data and functionality. Securing them requires more than just choosing an authentication method: you must also manage sessions carefully, handle tokens securely, and enforce both authentication and authorisation. By following best practices for session management (secure, HttpOnly and SameSite cookies limited scope, appropriate expiration, and by mitigating broken authentication through strong credentials, MFA and proper token handling, you can minimise the vulnerabilities and protect systems against common API attacks.

[^1]: A **replay attack** involves intercepting a valid request and resending it to impersonate a user or repeat an action. Basic authentication is vulnerable to replay attacks because the same credentials are sent with every request and can be reused if intercepted.

[^2]: A method where an attacker repeatedly tries different username and password combinations to gain unauthorised access. Basic authentication is vulnerable to brute-force attacks because credentials are simple and can be rapidly tested unless mitigated by server protections.

[^3]: A session is a **logical concept** that represents the ongoing interaction between a client and a server. It often tracks state, like who the user is, whether they’re logged in, and what they’re doing. Sessions persist **across multiple requests**, even if those requests open and close separate network connections (as is common with HTTP).

[^4]: An automated attack where stolen usernames and passwords from one site are used to log in to other websites. It exploits the common practice of password reuse and can lead to account takeovers.

[^5]: Rate limiting restricts how frequently requests can be made. This limits system to abuse such as brute-force attacks or credential stuffing, as attackers cannot send unlimited requests without being blocked.
